input {
  # Beats input from Filebeat
  beats {
    port => 5044
    type => "beats"
  }

  # Syslog input
  syslog {
    port => 5045
    type => "syslog"
  }

  # TCP input for custom logs
  tcp {
    port => 5000
    type => "tcp"
    codec => json {
      target => "[parsed]"
    }
  }
}

filter {
  # Parse Cowrie honeypot logs
  if [type] == "cowrie" or [log][file][path] =~ "cowrie" {
    mutate {
      add_field => { "[@metadata][target_index]" => "cowrie-logs" }
    }
    
    if [message] =~ "^\\{" {
      json {
        source => "message"
        target => "cowrie"
      }
    }
    
    # Extract event type
    if [cowrie][eventid] {
      mutate {
        add_field => { "event_type" => "%{[cowrie][eventid]}" }
      }
    }
    
    # GeoIP enrichment for source IP
    if [cowrie][src_ip] {
      geoip {
        source => "[cowrie][src_ip]"
        target => "source_geo"
        database => "/usr/share/logstash/GeoLite2-City.mmdb"
      }
    }
  }

  # Parse Zeek logs
  else if [type] == "zeek" or [log][file][path] =~ "zeek" {
    mutate {
      add_field => { "[@metadata][target_index]" => "zeek-logs" }
    }
    
    # Zeek TSV format parsing
    if [message] =~ "^#fields" {
      drop {}
    }
    
    csv {
      separator => "\t"
      columns => ["ts","uid","id.orig_h","id.orig_p","id.resp_h","id.resp_p","proto","service","duration","orig_bytes","resp_bytes","conn_state","local_orig","local_resp","missed_bytes","history","orig_pkts","orig_ip_bytes","resp_pkts","resp_ip_bytes","tunnel_parents"]
      skip_header => true
    }
    
    date {
      match => ["ts", "UNIX"]
      target => "@timestamp"
    }
  }

  # Parse Suricata logs
  else if [type] == "suricata" or [log][file][path] =~ "suricata" {
    mutate {
      add_field => { "[@metadata][target_index]" => "suricata-logs" }
    }
    
    json {
      source => "message"
      target => "suricata"
    }
    
    # Extract alert severity
    if [suricata][alert] {
      mutate {
        add_field => { "alert_severity" => "%{[suricata][alert][severity]}" }
        add_field => { "alert_signature" => "%{[suricata][alert][signature]}" }
      }
    }
    
    # GeoIP for source IP
    if [suricata][src_ip] {
      geoip {
        source => "[suricata][src_ip]"
        target => "source_geo"
      }
    }
  }

  # Parse system logs
  else if [type] == "syslog" {
    mutate {
      add_field => { "[@metadata][target_index]" => "syslog-logs" }
    }
    
    grok {
      match => {
        "message" => [
          "<%{POSINT:syslog_pri}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\\[%{POSINT:syslog_pid}\\])?: %{GREEDYDATA:syslog_message}",
          "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\\[%{POSINT:syslog_pid}\\])?: %{GREEDYDATA:syslog_message}"
        ]
      }
    }
    
    date {
      match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      target => "@timestamp"
    }
  }

  # Docker container logs
  else if [container][name] {
    mutate {
      add_field => { "[@metadata][target_index]" => "docker-logs" }
    }
    
    json {
      source => "message"
      target => "docker"
      skip_on_invalid_json => true
    }
  }

  # Common enrichment for all logs
  if [source][ip] {
    geoip {
      source => "[source][ip]"
      target => "source_geo"
    }
  }
  
  # Add SIEM metadata
  mutate {
    add_field => { 
      "siem_version" => "1.0"
      "ingest_timestamp" => "%{@timestamp}"
    }
  }
  
  # Remove unnecessary fields
  mutate {
    remove_field => [ "[event][original]", "agent", "ecs" ]
  }
}

output {
  # Dynamic index routing
  if [@metadata][target_index] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "%{[@metadata][target_index]}-%{+YYYY.MM.dd}"
      template_name => "siem-template"
      template_overwrite => true
    }
  } else {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "siem-logs-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output (comment out in production)
  # stdout { codec => rubydebug }
}
